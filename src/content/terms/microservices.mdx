---
title: "Microservices"
description: "En arkitektonisk tilgang hvor en applikation opbygges som en samling af små, uafhængige tjenester der kommunikerer via API'er."
tags: ["architecture", "backend", "distributed-systems", "advanced"]
datePublished: 2023-08-04
---

## What is Microservices?

Microservices architecture is an approach to software development where an application is built as a collection of small, loosely coupled services, each focused on a specific business capability. These services operate independently, can be developed, deployed, and scaled separately, and communicate with each other through well-defined APIs.

## Simple Analogy

Think of microservices like a modern restaurant kitchen versus a one-person food truck:

- **Monolithic Architecture (Food Truck)**: One chef handles everything from taking orders to preparing all dishes, cleaning, and serving. If the chef gets sick or overwhelmed, the entire operation stops. Adding a new menu item means retraining that single chef and potentially disrupting the entire workflow.

- **Microservices Architecture (Restaurant Kitchen)**: 
  - The restaurant has specialized stations: grill, salad, dessert, etc.
  - Each station has a dedicated chef focusing on just their specialty
  - Stations communicate through a standard system (like order tickets)
  - Stations operate independently but collaborate to create the full meal
  - If the dessert station gets busy, you can add another dessert chef without disturbing other stations
  - If the salad chef falls ill, the grill station can continue operating

Benefits of this approach include:
- Each station can use different tools best suited for their specific job
- Stations can be individually upgraded or modified
- A problem at one station doesn't shut down the entire kitchen
- Individual stations can be scaled up during peak demand (more dessert chefs during holidays)
- New chefs can be trained faster because they only need to learn one specific role

## Key Concepts

- **Service Independence**: Each service is self-contained with its own logic and database
- **Domain-Driven Design**: Services are organized around business capabilities
- **API Gateway**: A single entry point that routes requests to appropriate services
- **Service Discovery**: Mechanism for services to find and communicate with each other
- **Containerization**: Packaging services in containers for consistent deployment
- **Orchestration**: Managing the deployment and scaling of multiple services
- **Resilience**: Designing the system to handle failures in individual services
- **Event-Driven Communication**: Services can communicate through events and message queues

## Example

```yaml
# Docker Compose file for a microservices-based e-commerce application
version: '3'

services:
  # API Gateway
  api-gateway:
    image: api-gateway:latest
    ports:
      - "80:80"
    depends_on:
      - auth-service
      - product-service
      - order-service
    environment:
      - SERVICE_REGISTRY_URL=http://service-registry:8761/eureka

  # Authentication Service
  auth-service:
    image: auth-service:latest
    ports:
      - "8081:8081"
    depends_on:
      - auth-db
    environment:
      - SPRING_DATASOURCE_URL=jdbc:mysql://auth-db:3306/auth
    deploy:
      replicas: 2

  # Product Catalog Service
  product-service:
    image: product-service:latest
    ports:
      - "8082:8082"
    depends_on:
      - product-db
    environment:
      - DB_HOST=product-db
      - DB_PORT=27017
    deploy:
      replicas: 3

  # Order Processing Service
  order-service:
    image: order-service:latest
    ports:
      - "8083:8083"
    depends_on:
      - order-db
      - kafka
    environment:
      - DATABASE_URL=postgres://user:pass@order-db:5432/orders
      - KAFKA_BROKERS=kafka:9092
    deploy:
      replicas: 2

  # Databases for each service
  auth-db:
    image: mysql:8.0
    environment:
      - MYSQL_DATABASE=auth
      - MYSQL_ROOT_PASSWORD=secret

  product-db:
    image: mongo:latest
    volumes:
      - product-data:/data/db

  order-db:
    image: postgres:13
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
      - POSTGRES_DB=orders

  # Message Broker for Event-Driven Communication
  kafka:
    image: confluentinc/cp-kafka:latest
    depends_on:
      - zookeeper
    environment:
      - KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181
      - KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://kafka:9092

  zookeeper:
    image: confluentinc/cp-zookeeper:latest

volumes:
  product-data:
``` 